
%% This is an abbreviated template from http://www.sigplan.org/Resources/Author/.

\documentclass[acmsmall,review,authorversion]{acmart}
\acmDOI{}
\acmJournal{FACMP}
\acmVolume{CSCI 5535}
\acmNumber{Spring 2020}

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Towards Python for Serverless Acceleration}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Dylan Fox}
\email{dylan.fox@colorado.edu}
\author{Erika Hunhoff}
\email{erika.hunhoff@colorado.edu}
\affiliation{%
  \institution{University of Colorado Boulder}
}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
     Serverless computing offers many benefits for programmers, but frequently, slower interpreted languages like Python or JavaScript are used. In their 2019 work, Emily Herbert and Arjun Goha developer a serverless function accelerator that traces and compiles JavaScript to much more performant Rust code. Here, we extend their accelerator to trace and compile Python code as well as JavaScript, allowing more code bases to utilize the accelerator.
\end{abstract}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

In their 2019 work, Emily Herbert and Arjun Goha developed a serverless function accelerator. This accelerator traces JavaScript serverless functions at run-time, and produces an intermediate representation of the program. This intermediate representation is then compiled to Rust code which can be run in place of the JavaScript function. Here, we extend their work by providing a tracing mechanism for Python code. After we trace the python code, we compile it to Rust using their Rust compiler. 
 \par
 Transforming the Python code to A-Normal Form resolves differences in scoping between Python and Rust, and simplifies the tracing and compilation to Rust.
 \par
 Our Python A-Normal Form Code follows three specifications:
\begin{enumerate}
    \item All variables defined in functions or modules are initialized to None at the top of the function or module they are initially defined in. 
    \item All loops are while loops.
    \item All function applications are named.
\end{enumerate}
After A-Normalization, the resulting A-Normal Form Python code has tracing statements inserted into it. All expressions are transformed to be method calls to our tracing library. At run-time, the tracing library outputs the intermediate representation of the code being executed to a JSON file, then executes the Python code. After a number of invocations of the Python serverless function, the JSON file with the intermediate representation is compiled to Rust. Further invocations of the serverless function run the Rust code instead of the Python code. 

\section{Overview}

In the serverless accelerator framework created by Herbert \& Guha (hereby referred to as 'containerless'), a JavaScript function goes through several distinct phases:
\begin{enumerate}
    \item Normalization
    \item Addition of Tracing Statements
    \item Tracing to produce IR
    \item Compilation from IR to Rust
    \item Invoker uses Rust representation and Original JavaScript function to attempt to accelerate run time safely
\end{enumerate}
The goal of this work is to create normalization and tracing implementations that can produce compatible IR files from serverless functions written in Python. Since our goal is to avoid any changes to the IR, we are limited in what Python features we can support by what is already supported in our IR. This is the first challenge: match the supported syntax in JavaScript to a subset of Python that we will support. Details of this process are found in Section \ref{section:pysyntax}.
\par
The normalization phase in containerless uses A-Normal Form to take as input JavaScript functions (using the limited features supported) and output normalized JavaScript which is guaranteed to be traced completely during the tracing phase. To give a concrete example, if the following Python function were submitted to our framework:
%% TODO(erika): reformat these examples as figures, preferably side-by-side
\begin{verbatim}
def func():
    y = []
    x = [1, 2, 3]
    for index in range(len(x)):
        y[index] = x[index]
        
    if y[1] == 2:
        result = 'ok'
    else:
        print('Not Ok')
        result = 'not ok'
        
    return result
\end{verbatim}
The output of the normalization would be:
\begin{verbatim}
def func():
    y = None
    x = None
    result = None
    
    loop_incrementor0 = None
    app0 = None
    
    y = []
    x = [1, 2, 3]
    
    loop_incrementor0 = 0
    while loop_incrementor0 < len(range(len(x))):
        index = range(len(x))[loop_incrementor]
        y[index] = x[index]
        loop_incrementor0 += 1
        
    if y[1] == 2:
        result = 'ok'
    else:
        app0 = print('Not Ok')
        result = 'not ok'
        
    return result
\end{verbatim}
(Author's Note: These will be reformatted, probably to be side by side, in the final version of this document).

In addition to pursuing the same tracing guarantees in normalization, we also use this phase to address some of the syntactic differences between JavaScript and Python, so that our tracing can mimic the tracing used by containerless. For instance, in JavaScript variables can be declared (use of the 'var' keyword) and are forcibly declared during normalization which then helps determine variable scope during tracing. Since no analogous statement in Python exists, our normalization framework creates 'var = None' statements at the beginning of each function which serve a similar purpose as the declarations used in containerless normalization. More details on the normalization procedure is described in detail in \ref{section:anf}. 
\par 
The tracing phase takes as input a normalized function and outputs IR in JSON files. For instance, the previous example could output the following trace:
\begin{verbatim}
    TODO: once we have tracing actually working, we will post example here
\end{verbatim}
This is the last step of our development. One aspect that makes the tracing phase difficult is that JavaScript serverless functions and Python serverless functions have a slightly different workflow. JavaScript functions receive their input as a request object (and access this object by 'listening'), and 'return' by calling asynchronous return functions. Python serverless functions, on the other hand, take as input a single JSON text argument, and return a single JSON output. Thus, although the mechanics of tracing were similar, the framework for running traces had to be reworked for this new format. Details on tracing are found in \ref{section:tracing}.
\par
There are two main categories of evaluation for our work: performance and correctness. Since we focus not on the function invoker or system as a whole but on syntactic definitions, transformations, and tracing, we focus our evaluation on correctness. We measure correctness at all stages by checking whether normalized functions produce the same outputs as original functions, whether traces produced can be compiled into Rust without error, and whether the Rust executes with the same result as the original python. Details on evaluation are found in \ref{section:evaluation}.

\section{Supported Python Syntax}
\label{section:pysyntax}

TODO for HW06

\[\begin{array}{lrcll}
BinaryOp & op2 & ::= & + & \text{Addition}
\\
&&& - & \text{Subtraction}
\\
&&& * & \text{Multiplication}
\\
&&& / & \text{Division}
\\
&&& == & \text{Equals}
\\
&&& != & \text{Not equals}
\\
&&& < & \text{Less than}
\\
&&& <= & \text{Less than or equal to}
\\
&&& > & \text{Greater than}
\\
&&& >= & \text{Greater than or equal to}
\\
&&& and & \text{And}
\\
&&& or & \text{Or}
\\
UnaryOp & op1 & ::= & not & \text{Logical negation}
\\ 
&&& - & \text{Negate}
\\
Exp & exp & ::= & Name & \text{Variable}
\\
&&& Exp(<Exp>*) & \text{Function call}
\\
&&& Exp.Name & \text{Attribute access}
\\
&&& Exp[Exp] & \text{Slice access}
\\
&&& Exp BinOp Exp & \text{Binary operation}
\\
&&& UnaryOp Exp & \text{Unary operation}
\\
&&& Int & \text{Integer}
\\
&&& Bool & \text{Boolean}
\\
&&& String & \text{String}
\\
&&& [<Exp>*] & \text{List}
\\
&&& {<Exp:Exp>*} & \text{Dictionary}
\\
&&& Name = Exp & \text{Variable assignment}
\\
&&& Exp[Exp] = Exp & \text{Slice assignment}
\\
&&& Exp.Name = Exp & \text{Attribute assignment}
\\
&&& def Name(<Name>*) : Block & \text{Function definition}
\\
&&& return Exp & \text{Return}
\\
&&& if Exp: Block else: Block & \text{If-then-else}
\\
&&& while Exp: Block & \text{While}
\\
\end{array}\]

\section{A-Normal Form Transformation}
\label{section:anf}

TODO for HW06

%  In Python, variables are scopes much differently than in Rust. Rust supports block scoping, meaning you can scope a variable to any arbitrary block of code. Python only supports scoping at the function, class, and module levels.In practice, this means that all variables defined in while loops, for loops, if/else statements etc. are hoisted to the nearest class, function, or module level. In Python, a variable can be defined inside one block of code and used outside that block as long as it is inside the same module, function, or class. If directly translated to Rust, this variable hoisting would result in undefined variable errors, because Rust implements scoping at a block level.

\section{Tracing}
\label{section:tracing}

TODO for HW06

\section{Evaluation}
\label{section:evaluation}

TODO for HW06

\section{Related Work}
\label{section:relwork}

Our work builds on the concepts and code presented in Herbert and Guha \cite{ServerlessAccel}, which was build upon the principles presented in \cite{FormalFoundations}. \cite{ServerlessAccel} focuses on the entire process of creating a JavaScript to IR framework, an IR to Rust compilation process, and a serverless function invoker compatible with OpenWhisk \cite{OpenWhisk}. Our work is more narrow, and seeks to modify the JavaScript to IR phase into a Python to IR process.


Work has been done towards formalizing a semantics for Python \cite{pyOpSem}, and there are many tools and libraries for instrumenting Python code that this work builds upon (such as \cite{rpython}). However, our work is specifically geared towards the subset of Python needed to write serverless functions. This is in contrast with existing work which focuses on either creation of general purpose tools or solutions for a particular case (other than serverless).

\section{Conclusion}

TODO by paper deadline

%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
\begin{acks}
TBD
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{paper}
\end{document}
