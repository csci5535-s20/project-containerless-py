
%% This is an abbreviated template from http://www.sigplan.org/Resources/Author/.

\documentclass[acmsmall,review,authorversion]{acmart}
\acmDOI{}
\acmJournal{FACMP}
\acmVolume{CSCI 5535}
\acmNumber{Spring 2020}

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Towards Python for Serverless Acceleration}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Dylan Fox}
\email{dylan.fox@colorado.edu}
\author{Erika Hunhoff}
\email{erika.hunhoff@colorado.edu}
\affiliation{%
  \institution{University of Colorado Boulder}
}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
     Serverless computing offers many benefits for programmers, but frequently, slower interpreted languages like Python or JavaScript are used. In their 2019 work, Emily Herbert and Arjun Guha developer a serverless function accelerator that traces and compiles JavaScript to much more performant Rust code. Here, we extend their accelerator to trace and compile Python code as well as JavaScript, allowing more code bases to utilize the accelerator.
\end{abstract}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

In their 2019 work, Emily Herbert and Arjun Guha developed a serverless function accelerator. This accelerator traces JavaScript serverless functions at run-time, and produces an intermediate representation of the program. This intermediate representation is then compiled to Rust code which can be run in place of the JavaScript function. Here, we extend their work by providing a tracing mechanism for Python code. After we trace the python code, we compile it to Rust using their Rust compiler. 
 \par
 Transforming the Python code to A-Normal Form resolves differences in scoping between Python and Rust, and simplifies the tracing and compilation to Rust.
 \par
 Our Python A-Normal Form Code follows three specifications:
\begin{enumerate}
    \item All variables defined in functions or modules are initialized to None at the top of the function or module they are initially defined in. 
    \item All loops are while loops.
    \item All function applications are named.
\end{enumerate}
After A-Normalization, the resulting A-Normal Form Python code has tracing statements inserted into it. All expressions are transformed to be method calls to our tracing library. At run-time, the tracing library outputs the intermediate representation of the code being executed to a JSON file, then executes the Python code. After a number of invocations of the Python serverless function, the JSON file with the intermediate representation is compiled to Rust. Further invocations of the serverless function run the Rust code instead of the Python code. 

\section{Overview}

In the serverless accelerator framework created by Herbert \& Guha (hereby referred to as 'containerless'), a JavaScript function goes through several distinct phases:
\begin{enumerate}
    \item Normalization
    \item Addition of Tracing Statements
    \item Tracing to produce IR
    \item Compilation from IR to Rust
    \item Invoker uses Rust representation and Original JavaScript function to attempt to accelerate run time safely
\end{enumerate}
The goal of this work is to create normalization and tracing implementations that can produce compatible IR files from serverless functions written in Python. Since our goal is to avoid any changes to the IR, we are limited in what Python features we can support by what is already supported in our IR. This is the first challenge: match the supported syntax in JavaScript to a subset of Python that we will support. Details of this process are found in Section \ref{section:pysyntax}.
\par
The normalization phase in containerless uses A-Normal Form to take as input JavaScript functions (using the limited features supported) and output normalized JavaScript which is guaranteed to be traced completely during the tracing phase. To give a concrete example, if the following Python function were submitted to our framework:
%% TODO(erika): reformat these examples as figures, preferably side-by-side
\begin{verbatim}
def func():
    y = 0
    array_x = [1, 2, 3]
    for x in array_x:
        y += x
        
    if y == 6:
        result = 'ok'
    else:
        print('Not Ok')
        result = 'not ok'
        
    return result
\end{verbatim}
The output of the normalization would be:
\begin{verbatim}
def func():
    y = None
    array_x = None
    x = None
    result = None
    loop_incrementor0 = None
    app0 = None
    
    y =  0
    x = [1, 2, 3]
    
    loop_incrementor0 = 0
    while loop_incrementor0 < len(array_x):
        x = array_x[loop_incrementor]
        y += x
        loop_incrementor0 += 1
        
    if y == 2:
        result = 'ok'
    else:
        app0 = print('Not Ok')
        result = 'not ok'
        
    return result
\end{verbatim}
(the above will be formatted in the final paper as per you suggestions Benno)

In addition to pursuing the same tracing guarantees in normalization, we also use this phase to address some of the syntactic differences between JavaScript and Python, so that our tracing can mimic the tracing used by containerless. For instance, in JavaScript variables can be declared (use of the 'var' keyword) and are forcibly declared during normalization which then helps determine variable scope during tracing. Since no analogous statement in Python exists, our normalization framework creates 'var = None' statements at the beginning of each function which serve a similar purpose as the declarations used in containerless normalization. More details on the normalization procedure is described in detail in \ref{section:anf}. 
\par 
The tracing phase takes as input a normalized function and outputs IR in JSON files. For instance, the previous example could output the following trace:
\begin{verbatim}
    TODO: once we have tracing actually working, we will post example here
\end{verbatim}
This is the last step of our development. One aspect that makes the tracing phase difficult is that JavaScript serverless functions and Python serverless functions have a slightly different workflow. JavaScript functions receive their input as a request object (and access this object by 'listening'), and 'return' by calling asynchronous return functions. Python serverless functions, on the other hand, take as input a single JSON text argument, and return a single JSON output. Thus, although the mechanics of tracing were similar, the framework for running traces had to be reworked for this new format. Details on tracing are found in \ref{section:tracing}.
\par
There are two main categories of evaluation for our work: performance and correctness. Since we focus not on the function invoker or system as a whole but on syntactic definitions, transformations, and tracing, we focus our evaluation on correctness. We measure correctness at all stages by checking whether normalized functions produce the same outputs as original functions, whether traces produced can be compiled into Rust without error, and whether the Rust executes with the same result as the original python. Details on evaluation are found in \ref{section:evaluation}.

\section{Supported Python Syntax}
\label{section:pysyntax}

Our initial goals are to fit within the the framework of containerless, and as such, the subset of supported Python does not introduce any additional features beyond those already supported in the Javascript-to-IR representation, which includes some very useful features - such as while loops - but does not allow integration of some very pythonic features, such as 'for all' loops, the 'in' keyword, and even the modulo operator. All supported Python syntax is supported within the tracing framework, and is detailed below.

(TODO we are waiting for the final version before cleaning up formatting, but we will do so).
\[\begin{array}{lrcll}
BinaryOp & op2 & ::= & + & \text{Addition}
\\
&&& - & \text{Subtraction}
\\
&&& * & \text{Multiplication}
\\
&&& / & \text{Division}
\\
&&& == & \text{Equals}
\\
&&& != & \text{Not equals}
\\
&&& < & \text{Less than}
\\
&&& <= & \text{Less than or equal to}
\\
&&& > & \text{Greater than}
\\
&&& >= & \text{Greater than or equal to}
\\
&&& and & \text{And}
\\
&&& or & \text{Or}
\\
UnaryOp & op1 & ::= & not & \text{Logical negation}
\\ 
&&& - & \text{Negate}
\\
Exp & exp & ::= & Name & \text{Variable}
\\
&&& Exp(<Exp>*) & \text{Function call}
\\
&&& Exp.Name & \text{Attribute access}
\\
&&& Exp[Exp] & \text{Slice access}
\\
&&& Exp BinOp Exp & \text{Binary operation}
\\
&&& UnaryOp Exp & \text{Unary operation}
\\
&&& Int & \text{Integer}
\\
&&& Bool & \text{Boolean}
\\
&&& String & \text{String}
\\
&&& [<Exp>*] & \text{List}
\\
&&& {<Exp:Exp>*} & \text{Dictionary}
\\
&&& Name = Exp & \text{Variable assignment}
\\
&&& Exp[Exp] = Exp & \text{Slice assignment}
\\
&&& Exp.Name = Exp & \text{Attribute assignment}
\\
&&& def Name(<Name>*) : Block & \text{Function definition}
\\
&&& return Exp & \text{Return}
\\
&&& if Exp: Block else: Block & \text{If-then-else}
\\
&&& while Exp: Block & \text{While}
\\
\end{array}\]

\section{A-Normal Form Transformation}

\label{section:anf}
 In Python, variables are scoped much differently than in Rust. Rust utilizes block scoping, meaning variables are scoped to the block of code they are declared in. If a variable is declared inside a loop, conditional, or other block of code, the variable cannot be accessed outside the block. On the other hand, Python only supports scoping at the function, class, and module levels. So, in Python, all variables defined in while loops, for loops, if/else statements, etc... are available at the nearest class, function, or module level. If directly translated to Rust, this scoping would result in errors if the programmer defined a variable inside a loop, conditional, or other sub-block and then tried to access it outside the block it was defined in. To preserve this functionality of Python, our ANF transformer creates a variable declaration for every variable at the top of the nearest module or function. The variable declaration simply sets the variable to None so that the variables scope is preserved. If variables are declared at a higher scope (eg. in a closure), we do not reinitialize the variable to None at the beginning of the lower scope, we only change the higher scope.  We do not support the use of object oriented programming here, so we don't normalize variables in classes, focusing on modules and functions instead 
 \par
 Our ANF-Transformer also converts all for loops to while loops. In Rust for loops are actually quite similar to Python for loops. Both languages use for loops that iterate over an iterator and do not support direct C style for loops. Both Rust and Python also have iterators that can be infinite. To avoid the possibility of infinite looping, for loops are converted to while loops, and we only support iterating over index-able finite collections. An example of a for loop transformation is found below:
\begin{verbatim}
    for x in array_x:
        y += x
 \end{verbatim}
 
 Is transformed to: 
 \begin{verbatim}
    loop_incrementor0 = 0
    while loop_incrementor0 < len(array_x):
        x = array_x[loop_incrementor]
        y += x 
        loop_incrementor0 += 1
\end{verbatim}
(the above will be formatted in the final paper as per you suggestions Benno)
Here, we first wrap the iterator in a call to the builtin len function, to ascertain the length of the iterator. Then we instantiate a new variable to track the number of times the while loop has been run. The target variable is also moved inside the loop and set to to the iterator indexed to the current loop iteration. Finally, we increment the tracker variable inside the loop. 

\par 
During ANF normalization, we also name unnamed function applications.  This is primarily done to comply with the specs for the intermediate representation of Containerless and to keep the A-Normal Form code in compliance with common definitions of A-Normal Form Code. It should be noted that we do not provide a name to the applications of the builtin len function in Python. This is acceptable because there is no analogous built in function in Containerless' IR or in Rust. Rather, in Rust the array class contains a method to ascertain the length of the array. In Javascript and Containerless' IR, the length is a property of the array. When Python code is traced on our environment, the calls to len are replaced with a call to get the length property of the array, to conform with the Containerless IR. Therefore, applications of the len builtin function do not need to be named by the ANF normalizer. 

\section{Tracing}
\label{section:tracing}

There are two distinct phases of tracing. First, the source code of a ANF normalized Python function must be transformed to contain calls (in addition to the original code) to the tracing infrastructure. 
Then the resulting Python function must be run, producing JSON traces that could be used to compile to Rust in Containerless. 

To insert the tracing statements into a Python function, we first insert an "import" statement to import our tracing library.
Next, for every statement, we import the correct tracing function. For example, a call to the traceSet function must proceed any python code that sets the value of a variable.

After the tracing library statements are inserted into the source code, we can run our function, and both execute the function, and produce a trace. 

When JavaScript serverless functions are run in container-mode within the containerless framework, they run within the node.js environment. As a consequence of this, the JavaScript functions run using the common asynchronous request/response format in web programming. Using OpenWhisk as an example - where JavaScript functions agan run using node.js but other languages run in other runtimes - we stubbed out our own Python runtime for containerless tracing that uses JSON dictionaries as the function parameter and function response. This tracing runtime allowed us to produce Python traces without utilizing a serverless invoker. 

\section{Evaluation}
\label{section:evaluation}

Since this work did not encompass modifications to the invoker, and indeed, containerless does not run Python functions in any capacity, it was not possible to run performance tests using the containerless infrastructure. Thus, our evaluation focuses on correctness of the produced traces. Based on the limited number of Python functions supported, we constructed a series of test Python programs and pushed them through our system to produce traces. We then tested the original Python against the stripped traces to ensure they produced identical outputs with a variety of parameters engineering to guarantee full code coverage of the original test functions. A sample of an original Python function, the normalized functions, the annotated normalized function, the trace, and then the re-interpreted python code produced from the trace are shown below.

TODO: We will have this done by the time the project is due.

\section{Related Work}
\label{section:relwork}

Our work builds on the concepts and code presented in Herbert and Guha \cite{ServerlessAccel}, which was built upon the principles presented in \cite{FormalFoundations}. \cite{ServerlessAccel} focuses on the entire process of creating a JavaScript to IR framework, an IR to Rust compilation process, and a serverless function invoker compatible with OpenWhisk \cite{OpenWhisk}. Our work is more narrow, and seeks to modify the JavaScript to IR phase into a Python to IR process.


Work has been done towards formalizing a semantics for Python \cite{pyOpSem}, and there are many tools and libraries for instrumenting Python code that this work builds upon (such as \cite{rpython}). However, our work is specifically geared towards the subset of Python needed to write serverless functions. This is in contrast with existing work which focuses on either creation of general purpose tools or solutions for a particular case (other than serverless).

\section{Conclusion}

TODO by paper deadline

%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
\begin{acks}
TBD
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{paper}
\end{document}

